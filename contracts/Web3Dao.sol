// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "./EIP3664/ERC3664.sol";
import "./IWeb3Dao.sol";

contract Web3DAOCN is
    ERC3664,
    ERC721,
    AccessControlEnumerable,
    EIP712("WEB3DAO@CN", "1.0"),
    IWeb3DAOCN
{
    using Counters for Counters.Counter;
    /// @dev tokenID
    Counters.Counter private _tokenIdTracker;
    /// @dev constant bytes
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    // solhint-disable-next-line var-name-mixedcase
    bytes32 internal constant _PERMIT_TYPEHASH =
        keccak256(
            "approve(uint256 from,uint256 to,uint256 attrId,uint256 amount)"
        );

    /// @dev Attr transfer is allow
    mapping(uint256 => bool) public attrTransferAllow;

    constructor(string memory uri_)
        ERC3664(uri_)
        ERC721("Web3 DAO CN NFT", unicode"WEBÂ³")
    {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
    }

    modifier onlyMinter() {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            "Web3DAOCN: must have minter role to mint"
        );
        _;
    }

    modifier onlyHolder(uint256 tokenId) {
        require(
            ownerOf(tokenId) == _msgSender(),
            "Web3DAOCN: caller is not the nft holder"
        );
        _;
    }

    /**
     * @dev See {IERC721Enumerable-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _tokenIdTracker.current();
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to) public onlyMinter {
        _tokenIdTracker.increment();
        _safeMint(to, _tokenIdTracker.current());
    }

    /// @dev setAttrTransferAllow
    function setAttrTransferAllow(uint256 attrId, bool allow)
        public
        override
        onlyMinter
    {
        attrTransferAllow[attrId] = allow;
        emit AttrTransferAllow(attrId, allow);
    }

    /**
     * @dev Create new attribute type with metadata.
     *
     * See {ERC3664-_create}.
     */
    function create(
        uint256 _attrId,
        string memory _name,
        string memory _symbol,
        uint8 _decimal,
        string memory _uri
    ) public override onlyMinter {
        _create(_attrId, _name, _symbol, _decimal, _uri);
    }

    /**
     * @dev [Batched] version of {create}.
     */
    function createBatch(
        uint256[] calldata attrIds,
        string[] calldata names,
        string[] calldata symbols,
        uint8[] memory decimals,
        string[] calldata uris
    ) public override onlyMinter {
        _createBatch(attrIds, names, symbols, decimals, uris);
    }

    /**
     * @dev Mint `amount` value of attribute type `attrId` to `tokenId`.
     */
    function mint(
        uint256 tokenId,
        uint256 attrId,
        uint256 amount
    ) public override onlyMinter {
        _mint(tokenId, attrId, amount);
    }

    /**
     * @dev [Batched] version of {mint}.
     */
    function mintBatch(
        uint256 tokenId,
        uint256[] memory attrIds,
        uint256[] memory amounts
    ) public override onlyMinter {
        _mintBatch(tokenId, attrIds, amounts);
    }

    /**
     * @dev Destroys `amount` values of attribute type `attrId` from `tokenId`
     */
    function burn(
        uint256 tokenId,
        uint256 attrId,
        uint256 amount
    ) public override onlyMinter {
        _burn(tokenId, attrId, amount);
    }

    /**
     * @dev [Batched] version of {burn}.
     */
    function burnBatch(
        uint256 tokenId,
        uint256[] memory attrIds,
        uint256[] memory amounts
    ) public override onlyMinter {
        _burnBatch(tokenId, attrIds, amounts);
    }

    /**
     * @dev Approve attribute type `attrId` of token `from` to token `to` called by `from` holder.
     *
     * Emits an {AttributeApproval} event.
     */
    function approve(
        uint256 from,
        uint256 to,
        uint256 attrId,
        uint256 amount
    ) public override onlyHolder(from) {
        super.approve(from, to, attrId, amount);
    }

    /**
     * @dev Transfers attribute type `attrId` from token type `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     */
    function transfer(
        uint256 from,
        uint256 to,
        uint256 attrId,
        uint256 amount
    ) public override onlyHolder(from) {
        super.transfer(from, to, attrId, amount);
    }

    /**
     * @dev Sets a new URI for all attribute types
     */
    function setURI(string memory newuri) public onlyMinter {
        _setURI(newuri);
    }

    /**
     * @dev permit
     */
    function permit(
        uint256 from,
        uint256 to,
        uint256 attrId,
        uint256 amount,
        bytes memory signature
    ) public override {
        bytes32 structHash = keccak256(
            abi.encode(_PERMIT_TYPEHASH, from, to, attrId, amount)
        );
        bytes32 hash = _hashTypedDataV4(structHash);
        address signer = ECDSA.recover(hash, signature);
        require(ownerOf(from) == signer, "Permit: invalid signature");
        _approve(from, to, attrId, amount);
    }

    /**
     * @dev Hook that is called before any attribute transfer. This includes attaching
     * and removing, as well as batched variants.
     */
    function _beforeAttrTransfer(
        address operator,
        uint256 from,
        uint256 to,
        uint256 attrIds,
        uint256 amounts,
        bytes memory data
    ) internal virtual override {
        require(
            hasRole(MINTER_ROLE, operator) || attrTransferAllow[attrIds],
            "Web3DAOCN: Attr transfer not allow"
        );
        super._beforeAttrTransfer(operator, from, to, attrIds, amounts, data);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        require(
            balanceOf(to) == 0,
            "Web3DAOCN: Each address can only have one Token"
        );
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC3664, AccessControlEnumerable, ERC721)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
